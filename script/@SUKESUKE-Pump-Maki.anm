@ｻﾝｼｬｲﾝ画面
--track0:ー,0,100,0
--track1:ー,0,100,0
--track2:ー,0,100,0
--track3:ー,0,100,0
--dialog:ﾀﾝｸのx座標,tankX=760;ﾀﾝｸのy座標,tankY=433;ﾀﾝｸｻｲｽﾞ,tankSize=45;HPのx座標,hpX=779;HPのy座標,hpY=83;HPｻｲｽﾞ,hpSize=50;
--check0:位置確認,1

do

	--設定
	local hpActiveBorder = 0xF6A911 ;
	local hpDisableBorder = 0x4B4A50;
	local hpActiveLatitude = 0x40;
	local hpDisableLatitude = 0x50;
	local hpMixLatitude = 0xFF;
	
	local tankActiveBorder = 0x66DEED;
	local tankDisableBorder = 0x7F878A;
	local tankActiveLatitude = 0x30;
	local tankDisableLatitude = 0xFF;
	local tankMixLatitude = 0xFF;

	local hpSeg = 8;
	local tankSeg = 50;



	--立ち絵との通信変数(Global)
	if ws_tank == nil then
		ws_tank = 1;
	end
	if ws_hp == nil then
		ws_hp = 1;
	end
	if ws_tank_buffer == nil then
		ws_tank_buffer = {};
		for i = 0, tankSeg do
			ws_tank_buffer[i] = 0;
		end
	end
	if ws_hp_buffer == nil then
		ws_hp_buffer = {};
		for i = 0, hpSeg do
			ws_hp_buffer[i] = 0;
		end
	end
	if ws_timer_counter == nil then
		ws_timer_counter = 0;
	end
	if ws_setting == nil then
		ws_setting = {};
	end
	if true then
		ws_tankX = tankX;
		ws_tankY = tankY;
		ws_tankSize = tankSize;
		ws_hpX = hpX;
		ws_hpY = hpY;
		ws_hpSize = hpSize;
		--debug_print("Copyed param");
	end


	function Vector3Sub(v1, v2)
		local newVector = {};
		for i=1, 3 do
			if v1[i] > v2[i] then
				newVector[i] = v1[i] - v2[i];
			else
				newVector[i] = v2[i] - v1[i];
			end
		end
		return newVector;
	end
	function Vector3Magnitude(v)
		return math.sqrt(v[1]^2 + v[2]^2 + v[3]^2);
	end
	function Point(x, y, coler)
		for j = -1, 1 do
			for k = -1, 1 do
				obj.putpixel(x + j, y + k, coler, 1);
			end
		end
	end
	function Point2a(x, y, coler)
		Point(x, y, coler);
		Point(x+3, y, coler);
	end
	function Point2b(x, y, coler)
		Point(x, y, coler);
		Point(x, y+3, coler);
	end
	function Point4(x, y, coler)
		Point(x, y, coler);
		Point(x+3, y, coler);
		Point(x, y+3, coler);
		Point(x+3, y+3, coler);
	end
	function ArrayPoint(enumrator, coler)
		for i = 1, #enumrator do
			Point(enumrator[i][1], enumrator[i][2], coler);
		end
	end
	function ArrayPoint2(enumrator, x, y)
		for i = 1, #enumrator do
			Point4(x + i * 4, y, 0x000000);
		end
		for i = 1, #enumrator do
			Point(x + i * 4, y, enumrator[i]);
		end
	end
	function ArrayPoint22(enumrator, x, y)
		ArrayPoint2(enumrator, x, y);
		ArrayPoint2(enumrator, x, y+3);
	end
	function GetRgbFromCol(color)
		local b = color % (16 ^ 2);
		local g = math.floor(color % (16 ^ 4) / (16 ^ 2));
		local r = math.floor(color / (16 ^ 4));
		return r, g, b;
	end
	function GetColFromRgb(r, g, b)
		local col = r + 16^4 + g * 16^2 + b;
		return col;
	end
	function GetAverageInColorArray(colArry)
		local rSum = 0;
		local gSum = 0;
		local bSum = 0;
		for i = 1, #colArry do
			local r, g, b = GetRgbFromCol(colArry[i]);
			rSum = rSum + r;
			gSum = gSum + g;
			bSum = bSum + b;
		end
		return GetColFromRgb(rSum/#colArry, gSum/#colArry, rSum/#colArry);
	end
	function Sample(enumrator)
	
		--[[
		local colorsBuffer = {};
		for i = 1, #enumrator do
			local c = {};
			local a = {};
			local indexer = 0;
			for j = 0, 0 do
				for k = 0, 0 do
					indexer = indexer + 1;
					c[indexer], a[indexer] = obj.getpixel(enumrator[i][1]+j, enumrator[i][2]+k, "col");
				end
			end
			colorsBuffer[i] = GetAverageInColorArray(c); 
		end
		]]

		local colorsBuffer = {};
		for i = 1, #enumrator do
			local c, a = obj.getpixel(enumrator[i][1], enumrator[i][2], "col");
			colorsBuffer[i] = c;
		end
		return colorsBuffer;
	end
	function CheckColorInRange(color, up, under, latitude)
		local r, g, b = GetRgbFromCol(color);
		local rUp, gUp, bUp = GetRgbFromCol(up);
		local rUnder, gUnder, bUnder = GetRgbFromCol(under);
		local matchCount = 0;
		if(rUp + latitude >= r and r >= rUnder - latitude ) then
			matchCount = matchCount + 1;
		end
		if(gUp + latitude >= g and g >= gUnder - latitude ) then
			matchCount = matchCount + 1;
		end
		if(bUp + latitude >= b and b >= bUnder - latitude ) then
			matchCount = matchCount + 1;
		end
		return matchCount;
	end
	function CheckColorInRangeWrap(color, up, under, latitude)
		local matchCount = CheckColorInRange(color, up, under, latitude);
		if(matchCount == 3)then
			return true;
		end
		return false;
	end
	function CheckColorInRangeVectored(color, border)
		local r, g, b = GetRgbFromCol(border);
		local borderVector = {r, g, b};
		r, g, b = GetRgbFromCol(color);
		local colorVector = {r, g, b};
		local magnitude = Vector3Magnitude(Vector3Sub(colorVector, borderVector));
		return magnitude;
	end
	function CheckPump(color)
		local activeBorder = tankActiveBorder;
		local disableBorder = tankDisableBorder;
		if obj.check0 then
			local w, h = obj.getpixel();
			Point2a(5, h-19, activeBorder);
			Point2a(5, h-9, disableBorder);
		end
		local activeDistance = CheckColorInRangeVectored(color, activeBorder);
		local disableDistance = CheckColorInRangeVectored(color, disableBorder);
		return {activeDistance, disableDistance, color, activeBorder, disableBorder};
	end
	function CheckPumpWrap(color)
		local distances = CheckPump(color);
		if distances[1] < tankActiveLatitude then
			return 1;
		elseif distances[2] < tankDisableLatitude then
			return 0;
		elseif distances[1] + distances[2] < tankMixLatitude then
			return 1;
		else
			return -10000;
		end
	end
	function CheckHp(color)
		local activeBorder = hpActiveBorder ;
		local disableBorder = hpDisableBorder;
		if obj.check0 then
			local w, h = obj.getpixel();
			Point2a(15, h-19, activeBorder);
			Point2a(15, h-9, disableBorder);
		end
		local activeDistance = CheckColorInRangeVectored(color, activeBorder);
		local disableDistance = CheckColorInRangeVectored(color, disableBorder);
		do
			local r, g, b = GetRgbFromCol(activeBorder);
			local borderVector = {r, g, b};
			r, g, b = GetRgbFromCol(disableBorder);
			local colorVector = {r, g, b};
			local magnitude = Vector3Magnitude(Vector3Sub(colorVector, borderVector));
		end
		return {activeDistance, disableDistance, color, activeBorder, disableBorder};
	end
	function CheckHpWrap(color)
		local distances = CheckHp(color);
		if distances[2] < hpDisableLatitude then
			return 0;
		elseif distances[1] < hpActiveLatitude then
			return 1;
		elseif distances[1] + distances[2] < hpMixLatitude then
			return 1;
		else
			return -10000;
		end
	end
	function ArrayChack(enumrator, method)
		local n = 0;
		for	i = 1, #enumrator do
			n = n + method(enumrator[i]);
		end
		n = n / #enumrator;
		return n;
	end
	function ArrayChackNormalize(enumrator, method)
		local returnArray = {};
		local pallets = {};
		if method == CheckPumpWrap then
			pallets = {0x3333FF, 0x222222, 0x33FF33};
		end
		if method == CheckHpWrap then
			pallets = {0xFF3333, 0x222222, 0x33FF33};
		end
		for	i = 1, #enumrator do
			local c = method(enumrator[i]);
			if c == 1 then
				returnArray[i] = pallets[1];
			end
			if c == 0 then
				returnArray[i] = pallets[2];
			end
			if c < 0 then
				returnArray[i] = pallets[3];
			end
		end
		return returnArray;
	end
	function InitAverage(length)
		if not Inited then
			Average = {};
			Counter = {};
			Max = {};
			Min = {};
			for	i = 0, length do
				Average[i] = 0;
				Counter[i] = 0;
				Max[i] = 0;
				Min[i] = 0x10000000;
			end
			Inited = true;
		end
	end
	function GetAverage(value, index)
		if value > Max[index] then
			Max[index] = value;
		end
		if value < Min[index] then
			Min[index] = value;
		end
		Average[index] = Average[index] * Counter[index];
		Counter[index] = Counter[index] + 1;
		Average[index] = (Average[index] + value) / Counter[index];
		return Average[index];
	end

	--ﾀﾝｸのサンプリングPixelの座標列を取得
	local sampleTankPixels = {};
	for i = 1, tankSeg do
		sampleTankPixels[i] = {ws_tankX, ws_tankY + ws_tankSize / (tankSeg - 1) * i};
	end

	--HPのサンプリングPixelの座標列を取得
	local sampleHpPixels = {}
	for i = 1, hpSeg do
		local angle = i * 2 * math.pi * 0.90 / (hpSeg + 1) + math.pi * 1.11;
		sampleHpPixels[i] = {ws_hpX + ws_hpSize * math.sin(angle), ws_hpY + 0.95 * ws_hpSize * math.cos(angle)};
	end

	--サンプリング
	local sampleTankPixelColors = Sample(sampleTankPixels);
	local sampleHpPixelColors = Sample(sampleHpPixels);

	--抽出
	local tank = ArrayChack(sampleTankPixelColors, CheckPumpWrap);
	if tank >= 0 then
		ws_tank_buffer = sampleTankPixelColors;
		ws_tank = tank;
	end
	local hp = ArrayChack(sampleHpPixelColors, CheckHpWrap);
	if hp >= 0 then
		ws_hp_buffer = sampleHpPixelColors;
		ws_hp = hp;
	end

	--debug
	if obj.check0 then

	    --統計情報
		local rt1, gt1, bt1 = GetRgbFromCol(sampleHpPixelColors[1]);
		local rtn, gtn, btn = GetRgbFromCol(sampleHpPixelColors[#sampleHpPixelColors]);
		local trt1, tgt1, tbt1 = GetRgbFromCol(sampleTankPixelColors[1]);
		local trtn, tgtn, tbtn = GetRgbFromCol(sampleTankPixelColors[#sampleTankPixelColors]);
		local hpVec1 = CheckHp(sampleHpPixelColors[1]);
		local hpVec2 = CheckHp(sampleHpPixelColors[#sampleHpPixelColors]);
		local tankVec1 = CheckPump(sampleTankPixelColors[1]);
		local tankVec2 = CheckPump(sampleTankPixelColors[#sampleTankPixelColors]);
		InitAverage(16);
		local x, y = obj.getpixel();
		D = x .. "x" .. y .. "\
		" .. "Pump: " .. string.format("%X", sampleTankPixelColors[1]) .. " - " .. string.format("%X", sampleTankPixelColors[#sampleTankPixelColors]) .."\
		" .. "HP  : " .. string.format("%X", sampleHpPixelColors[1]) .. " - " .. string.format("%X", sampleHpPixelColors[#sampleHpPixelColors]) .. "\
		" .. "Info_hp1: " .. string.format("A: %X %X %X", GetAverage(rt1,1), GetAverage(gt1,2), GetAverage(bt1,3)) .. "\
		" .. "Info_hpn: " .. string.format("A: %X %X %X", GetAverage(rtn,4), GetAverage(gtn,5), GetAverage(btn,6)) .. "\
		" .. "Info_tk1: " .. string.format("A: %X %X %X", GetAverage(trt1,7), GetAverage(tgt1,8), GetAverage(tbt1,9)) .. "\
		" .. "Info_tkn: " .. string.format("A: %X %X %X", GetAverage(trtn,10), GetAverage(tgtn,11), GetAverage(tbtn,12)) .. "\
		" .. "Nge: " .."\
		\
		" .. "HP_rl:" .. string.format(" %X - %X - %X - %X", hpVec1[4] , hpVec2[3] ,hpVec1[3] , hpVec1[5]) .. "\
		" .. "HP_v1:" .. hpVec1[1] .. " - ".. hpVec1[2] .. "\
		" .. "HP_vn:" .. hpVec2[1] .. " - ".. hpVec2[2] .. "\
		\
		" .. "Pump_rl:" .. string.format(" %X - %X - %X - %X", tankVec1[4], tankVec1[3], tankVec2[3], tankVec1[5]) .. "\
		" .. "Pump_v1:" .. tankVec1[1] .. " - ".. tankVec1[2] .. "\
		" .. "Pump_vn:" .. tankVec2[1] .. " - ".. tankVec2[2] .. "\
		"  

		--メーター
		ArrayPoint22(sampleHpPixelColors, 10, 3);
		ArrayPoint22(sampleTankPixelColors, 50, 3);
		ArrayPoint22(ArrayChackNormalize(sampleHpPixelColors, CheckHpWrap), 10, 11);
		ArrayPoint22(ArrayChackNormalize(sampleTankPixelColors, CheckPumpWrap), 50, 11);
		ArrayPoint22(ArrayChackNormalize(ws_hp_buffer, CheckHpWrap), 10, 19);
		ArrayPoint22(ArrayChackNormalize(ws_tank_buffer, CheckPumpWrap), 50, 19);

		--位置合わせ用
		ArrayPoint(sampleTankPixels, 0x0000ff);
		ArrayPoint(sampleHpPixels, 0xff5500);
		
		--通過確認
		debug_print("Fin.");
	end
	
end


@ﾀﾝｸ
--track0:変数,0,100,0
--track1:変数,0,100,0
--track2:変数,0,100,0
--track3:変数,0,100,0
--check0:有効,1

if obj.check0 then
	obj.alpha = ws_tank;
end

@HP
--track0:破れの大きさ,0,1500,500
--track1:ｵﾌｾｯﾄX,-1000,1000,0
--track2:ｵﾌｾｯﾄY,-1000,1000,0
--track3:タイプ,0,6.01,5
--check0:有効,1

do
	if obj.check0 then

		function BreakDown(time)

			local size=50;
			local speed=100;
			local grav=100;
			local delay=100;
			local impact=100;
			local spin=100;
			local diff=100;
			local step=1.0;

			local px={}
			local py={}
			local pz={}
			local pu={}
			local pv={}
			if( step < 0 ) then 
				tm = obj.time*step+ time
			else
				tm = obj.time*step- time
			end
			if( tm < 0 ) then
				return
			end
			obj.effect()
			grav = grav*6
			delay = delay*0.002
			impact = impact*0.1
			spin = math.floor(spin*10)
			diff = diff/80
			if( size < 10 ) then
				size = 10
			end 
			xl = obj.w
			yl = obj.h
			ax = 0
			ay = 0
			az = 0
			sp = speed*0.01*math.sqrt(impact)
			w = math.floor(xl/size)
			h = math.floor(yl/size)
			l = math.sqrt(xl*xl+yl*yl)
			if( w < 2 ) then
				w = 2
			elseif( w > xl ) then
				w = xl
			end
			if( h < 2 ) then
				h = 2
			elseif( h > yl ) then
				h = yl
			end
			pw = xl/w/2.3
			ph = yl/h/2.3
			for y=0,h-1 do
				for x=0,w-1 do
					-- 各頂点を計算
					pu[0] = xl*x/w
					pu[1] = xl*(x+1)/w
					pu[2] = pu[1]
					pu[3] = pu[0]
					pv[0] = yl*y/h
					pv[1] = pv[0]
					pv[2] = yl*(y+1)/h
					pv[3] = pv[2]
					pu[0] = pu[0] + obj.rand(-pw,pw,x  ,y  )
					pu[1] = pu[1] + obj.rand(-pw,pw,x+1,y  )
					pu[2] = pu[2] + obj.rand(-pw,pw,x+1,y+1)
					pu[3] = pu[3] + obj.rand(-pw,pw,x  ,y+1)
					pv[0] = pv[0] + obj.rand(-ph,ph,x  ,y  +1000)
					pv[1] = pv[1] + obj.rand(-ph,ph,x+1,y  +1000)
					pv[2] = pv[2] + obj.rand(-ph,ph,x+1,y+1+1000)
					pv[3] = pv[3] + obj.rand(-ph,ph,x  ,y+1+1000)
					if( x == 0 ) then
						pu[0] = 0
						pu[3] = 0
					elseif ( x == w-1 ) then
						pu[1] = xl
						pu[2] = xl
					end
					if( y == 0 ) then
						pv[0] = 0
						pv[1] = 0
					elseif ( y == h-1 ) then
						pv[2] = yl
						pv[3] = yl
					end
					-- 基準の計算
					gx = (pu[0]+pu[1]+pu[2]+pu[3])/4
					gy = (pv[0]+pv[1]+pv[2]+pv[3])/4
					gz = 0
					cx = gx-xl/2
					cy = gy-yl/2
					cz = 0
					vx = cx-ax
					vy = cy-ay
					vz = -az
					v = math.sqrt(vx*vx+vy*vy+vz*vz)
					-- 時間の計算
					t = tm-v/l*delay
					if( t < 0 ) then
						t = 0
						obj.setoption('antialias',0)
					else
						obj.setoption('antialias',1)
					end
					-- 回転を計算
					xx = t*obj.rand(-spin,spin,x,y+2000)/100
					yy = t*obj.rand(-spin,spin,x,y+3000)/100
					zz = t*obj.rand(-spin,spin,x,y+4000)/100
					sin_x = math.sin(xx);
					cos_x = math.cos(xx);
					sin_y = math.sin(yy);
					cos_y = math.cos(yy);
					sin_z = math.sin(zz);
					cos_z = math.cos(zz);
					m00 =  cos_y*cos_z
					m01 = -cos_y*sin_z
					m10 =  cos_x*sin_z +sin_x*cos_z*sin_y
					m11 =  cos_x*cos_z -sin_x*sin_z*sin_y
					m20 =  sin_x*sin_z -cos_x*cos_z*sin_y
					m21 =  sin_x*cos_z +cos_x*sin_z*sin_y
					for i=0,3 do
						xx = pu[i]-gx
						yy = pv[i]-gy
						px[i] = m00*xx + m01*yy
						py[i] = m10*xx + m11*yy
						pz[i] = m20*xx + m21*yy
					end
					-- 表示座標を計算
					v = 1/(1+v*v/(l*l)*impact)
					vx = vx*v + obj.rand(-size,size,x,y+4000)*diff
					vy = vy*v + obj.rand(-size,size,x,y+5000)*diff
					vz = vz*v + obj.rand(-size,size,x,y+6000)*diff
					cx = cx + t*vx*sp
					cy = cy + t*vy*sp + t*t*grav
					cz = cz + t*vz*sp
					obj.drawpoly(px[0]+cx,py[0]+cy,pz[0]+cz,px[1]+cx,py[1]+cy,pz[1]+cz,px[2]+cx,py[2]+cy,pz[2]+cz,px[3]+cx,py[3]+cy,pz[3]+cz, pu[0],pv[0],pu[1],pv[1],pu[2],pv[2],pu[3],pv[3])
				end
			end
		end

		if ws_break == nil then
			ws_break = {};
			local w, h = obj.getpixel();
			for i = 1, 8 do
				ws_break[i] = {math.floor(math.random(-w/2,w/2)), math.floor(math.random(-h/2,h/2))};
			end
		end
		local breakPoint = 8 - math.floor(ws_hp * 8 + 0.1);
		if ws_breakPoint_pre == nil then
			ws_breakPoint_pre = breakPoint;
		end
		
		for i=1, breakPoint do
			--星型マスク
			obj.effect("マスク",
				"X",ws_break[i][1]+obj.track1,
				"Y",ws_break[i][2]+obj.track2,
				"サイズ",obj.track0,
				"マスクの反転",1,
				"type",math.floor(obj.track3)
			);
		end

		if breakPoint > ws_breakPoint_pre then
			local w, h = obj.getpixel();
			obj.drawpoly(-obj.w/2,-obj.h/2,0, obj.w/2,-obj.h/2,0, obj.w/2,obj.h/2,0, -obj.w/2,obj.h/2,0);
			ws_break_start = obj.time;
			BreakDown(ws_break_start);
			debug_print("breaked");
		end
		if ws_break_start ~= nil and (obj.time - ws_break_start) < 1 then
			obj.drawpoly(-obj.w/2,-obj.h/2,0, obj.w/2,-obj.h/2,0, obj.w/2,obj.h/2,0, -obj.w/2,obj.h/2,0);
			BreakDown(ws_break_start);
		else
			ws_break_start = nil;
		end

		ws_breakPoint_pre = breakPoint;
	end
end


@Dev
--dialog:コピペ,v="Debug: <?=D?>";
obj.text = D_a;

